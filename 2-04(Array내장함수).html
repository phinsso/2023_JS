<html>
<head>
    <title></title>
</head>
<body>
    <div id = "div1"></div>
    <script>
        // var fruits1 = ["Banana", "Orange", "Apple"];
        // console.log(fruits1.toString()); // 배열의 아이템들을 String형으로 변환하여 출력

        // join() : 배열의 모든 요소를 연결해 하나의 문자로 만듦
        //console.log(fruits1.join(" * "));
        // var txt1 = "Banana<br>";
        // txt1 += "Orange<br>";
        // txt1 += "Apple<br>";
        // document.getElementById("div1").innerHTML = txt1;


        // push() : 배열의 가장 마지막에 새로운 항목을 추가
        // var arr1 = [];
        // arr1.push("Banana");
        // arr1.push("Orange");
        // arr1.push("Apple");
        // document.getElementById("div1").innerHTML = arr1.join("<br>");


        // pop() : 배열의 가장 마지막 항목을 제거하여 리턴
        // var fruits2 = ["Banana", "Orange", "Apple"];
        // var arr2 = fruits2.pop();
        // console.log(arr2); // 출력값: Apple
        // console.log(fruits2); // 출력값: {"Banana", "Orange"}
        // fruits2.push("kiwi");
        // console.log(fruits2);


        // shift() : 배열의 첫번째 항목을 제거함
        // var fruits3 = ["Banana", "Orange", "Apple"];
        // var str = fruits3.shift();
        // console.log(str); // 출력값: Banana
        // console.log(fruits3); // 출력값: {"Orange", "Apple"}


        // unshift() : 배열의 첫번째에 새로운 항목을 추가
        // var fruits4 = ["Banana", "Orange", "Apple"];
        // fruits4.unshift("Lemon");
        // console.log(fruits4); // 출력값: {"Lemon", "Banana", "Orange", "Apple"}


        // splice(a, b) : 배열의 중간에 삽입/삭제 (a: 시작 인덱스 , b: 삭제할 개수)
        var fruits5 = ["Banana", "Orange", "Apple"];
        //fruits5.splice(1); // 1번 인덱스부터 다 삭제
        //console.log(fruits5);
        fruits5.splice(1, 0, "Lemon"); // 삭제 안 하고 1번 인덱스 다음에 Lemon 추가


        // concat() : 두 개의 배열을 하나로 만들어줌
        // var BTS1 = ["뷔"];
        // var BTS2 = ["정국", "RM"];
        // var BTS = BTS1.concat(BTS2);
        // console.log(BTS);


        // slice(a, b) : a부터 b-1까지 항목을 가져옴
        //var fruits6 = ["Banana", "Orange", "Apple"];
        //var fruits7 = fruits6.slice(1); // 1번 인덱스부터 끝까지
        // var fruits7 = fruits6.slice(1,2); // 1번 인덱스부터 1번 인덱스까지 (Orange)
        // console.log(fruits7);


        // sort() : 정렬 (문자열로 변환해서 정렬함)
        // var fruits8 = ["Banana", "Orange", "Apple", "Lemon", "Kiwi"];
        // console.log(fruits8.sort()); // 오름차순 정렬

        //var points = [40, 100, 70, 21, 99];
        /* console.log(points.sort(function(a, b) { // sort는 문자열로 비교를 하기 때문에 숫자의 경우 직접 정의해서 사용해야함
            if(a > b) return 1; // 양수 리턴
            else if(a < b) return -1; // 음수 리턴
            else return 0;
        })); */

        // console.log(points.sort(function(a, b) { // 위의 로직 축약
        //     return a - b; // 내림차순일 때는 b - a
        // }));

        //console.log(points.reverse()); // 거꾸로 출력


        // object 정렬
        // var persons = [
        //     {name: "유재석", point: 78}, // 객체
        //     {name: "김종국", point: 90},
        //     {name: "양세찬", point: 76},
        //     {name: "하하", point: 82}
        // ];

        /* persons.sort(function(a, b) {
            if(a.point > b.point) return 1;
            else if(a.point < b.point) return -1;
            else return 0;
        }); // 내림차순으로 하려면 1을 -1으로, -1을 1으로

        console.log(persons.sort()); */


        // 삼항연산자 (조건) ? true : false;
        // persons.sort(function(a,b) {
        //     return (a.point > b.point) ? 1 : (a.point < b.point) ? -1 : 0;
        // });
        // console.log(persons.sort());

        
        // filter() : 조건에 맞는 배열만 리턴
        // var pass = persons.filter(function(per) {
        //     return per.point > 80;
        // });
        // console.log(pass);

        var persons = [
            {name: "유재석", point: 78, city: "서울"}, // 객체
            {name: "김종국", point: 90, city: "대구"},
            {name: "양세찬", point: 76, city: "서울"},
            {name: "하하", point: 82, city: "제주"}
        ];

        // var jeju = persons.filter(function(per) { // per는 persons 배열의 각 객체를 가리킴 (처음엔 유재석 그 다음엔 김종국 ...)
        //     return per.city === "제주";
        // });
        // console.log(jeju);

        // filter()를 for문으로 구현
        // var jeju = [];
        // for(var i = 0; i < persons.length; i++) {
        //     if(persons[i].city === "제주") {
        //         jeju.push(persons[i]);
        //     }
        // }
        // console.log(jeju);


        // reduce(a , c)
        // a : accumulator(누산기)
        // c: currentValue

        var arr3 = [1, 2, 3, 4, 5];
        var total = 0;
        for(var i of arr3) {
            total += i;
        }
        console.log(total);


        var arr4 = [1, 2, 3, 4, 5];
        var total = arr4.reduce(function(a, c) {
            return a + c;
        });
        console.log(total);


        // map() : filter()와는 다른 형태로 새로운 배열을 생성
        var userList = [
            {firstName: "재석", lastName: "유", email: "yu@gmail.com"},
            {firstName: "종국", lastName: "김", email: "kim@gmail.com"},
            {firstName: "세찬", lastName: "양", email: "yang@gmail.com"},
            {firstName: "석진", lastName: "지", email: "ji@gmail.com"}

        ];

        var userList2 = userList.map(function(user) {
            return {fullName : "런닝맨 멤버 " + user.firstName + user.lastName}
        });
        console.log(userList2);
    
    </script>
</body>
</html>